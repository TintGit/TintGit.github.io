<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="keywords" content="iOS,OC,Objective-C,Swift,开发者,程序猿,程序媛,极客,编程,代码,开源,Developer">
<meta property="og:type" content="website">
<meta property="og:title" content="Unruly的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Unruly的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Unruly的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Unruly的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Unruly的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">心存善念，必有善行；善念善行，天必佑之。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-tags" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/25/拾遗/面经/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/拾遗/面经/" itemprop="url">iOS 面试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-25T00:00:00+08:00">
                2018-09-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="atomic-nonatomic区别和理解"><a href="#atomic-nonatomic区别和理解" class="headerlink" title="atomic nonatomic区别和理解"></a>atomic nonatomic区别和理解</h2><p>atomic的意思就是setter/getter这个函数，是一个原语操作。如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，可以保证数据的完整性。nonatomic不保证setter/getter的原语行，所以你可能会取到不完整的东西。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结</p>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><ul>
<li>NSKeyedArchiver -&gt; 用户信息</li>
<li>NSUserDefaults -&gt; 状态、版本</li>
<li>Write􏰴􏱼􏰲􏰳􏲅 -&gt; plist、txt等文件</li>
<li>数据库 -&gt; WCDB、FMDB等</li>
<li>CoreData -&gt; 苹果自带的数据库</li>
</ul>
<h2 id="深、浅拷贝"><a href="#深、浅拷贝" class="headerlink" title="深、浅拷贝"></a>深、浅拷贝</h2><ul>
<li>拷贝需实现 NSCopying协议</li>
<li>浅拷贝: 􏱭􏱙􏰵􏰈􏱊􏱋􏳽􏳄􏱜􏱯􏳾􏴏􏰩􏴐􏱃􏱜􏱯􏱭􏱙􏰵􏰈􏱊􏱋􏳽􏳄􏱜􏱯􏳾􏴏􏰩􏴐􏱃􏱜􏱯􏱭􏱙􏰵􏰈􏱊􏱋􏳽􏳄􏱜􏱯􏳾􏴏􏰩􏴐􏱃􏱜􏱯􏱭􏱙􏰵􏰈􏱊􏱋􏳽􏳄􏱜􏱯􏳾􏴏􏰩􏴐􏱃􏱜􏱯􏱭􏱙􏰵􏰈􏱊􏱋􏳽􏳄􏱜􏱯􏳾􏴏􏰩􏴐􏱃􏱜􏱯copy指针 指向相同地址</li>
<li>深拷贝: 新的对象 新的指针</li>
</ul>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (AccountManager *)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">       static AccountManager *staticInstance = nil;</span><br><span class="line">       static dispatch_once_t predicate;</span><br><span class="line">       dispatch_once(&amp;predicate, ^&#123;</span><br><span class="line">               staticInstance = [[self alloc] init];</span><br><span class="line">   return staticInstance;</span><br><span class="line">&#125;); &#125;</span><br></pre></td></tr></table></figure>
<h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><blockquote>
<p>RunLoop 是什么？RunLoop 还是比较顾名思义的一个东西，说白了就是一种循环，只不过它这种循环比较高级。一般的 while 循环会导致 CPU 进入忙等待状态，而 RunLoop 则是一种“闲”等待，这部分可以类比 Linux 下的 epoll。当没有事件时，RunLoop 会进入休眠状态，有事件发生时， RunLoop 会去找对应的 Handler 处理事件。RunLoop 可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠。</p>
</blockquote>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><blockquote>
<p>一个RunLoop对象，主要包含了一个线程，若干个Mode，若干个commonMode，还有一个当前运行的Mode</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;  /* locked for accessing mode list */</span><br><span class="line">    __CFPort _wakeUpPort;   // used for CFRunLoopWakeUp 内核向该端口发送消息可以唤醒runloop</span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData; // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;             //RunLoop对应的线程</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;    //存储的是字符串，记录所有标记为common的mode</span><br><span class="line">    CFMutableSetRef _commonModeItems;//存储所有commonMode的item(source、timer、observer)</span><br><span class="line">    CFRunLoopModeRef _currentMode;   //当前运行的mode</span><br><span class="line">    CFMutableSetRef _modes;          //存储的是CFRunLoopModeRef</span><br><span class="line">    struct _block_item *_blocks_head;//doblocks的时候用到</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>详见 <a href="https://juejin.im/post/5aca2b0a6fb9a028d700e1f8" target="_blank" rel="noopener">RunLoop详解</a></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote>
<p>一个 Timer 一次只能加入到一个 RunLoop 中。我们日常使用的时候，通常就是加入到当前的 runLoop 的 default mode 中，而 ScrollView 在用户滑动时，主线程 RunLoop 会转到 UITrackingRunLoopMode 。而这个时候， Timer 就不会运行</p>
</blockquote>
<p>有如下两种解决方案：</p>
<ul>
<li>设置 RunLoop Mode，例如 NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个 Mode 的集合。注册到这个 Mode 下后，无论当前 runLoop 运行哪个 mode ，事件都能得到执行。</li>
<li>在另外一个线程执行和处理 Timer 事件，然后在主线程更新 UI</li>
</ul>
<h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><h3 id="Autorelease-释放时机"><a href="#Autorelease-释放时机" class="headerlink" title="Autorelease 释放时机"></a>Autorelease 释放时机</h3><blockquote>
<p>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop(双向链表)</p>
</blockquote>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li>retain(􏰀􏰁􏰂􏰃􏰄引用计数+1)-&gt;release􏰅􏰀􏰁􏰂􏰃􏰆1(引用计数-1)</li>
<li>alloc（申请内存空间）-&gt; dealloc（释放内存空间）</li>
<li>readwrite 既有getter,也有setter（默认）</li>
<li>readonly 只有getter,没有setter</li>
<li>nonatomic 不考虑线程安全</li>
<li>原子性: atomic 线程操作安全（默认）nonatomic不使用自旋锁<br>比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。<br>而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。<br>不过atomic可并不能保证线程安全。如果线程 A 调了 getter，与此同时线程 B 、线程 C 都调了 setter——那最后线程 A get 到的值，3种都有可能：可能是 B、C set 之前原始的值，也可能是 B set 的值，也可能是 C set 的值。同时，最终这个属性的值，可能是 B set 的值，也有可能是 C set 的值。<br>保证数据完整性——这个多线程编程的最大挑战之一——往往还需要借助其他手段</li>
</ul>
<p>线程安全下的 setter、getter</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *) value</span><br><span class="line">&#123;</span><br><span class="line">  @synchronized(self) &#123;</span><br><span class="line">     return [[_value retain] autorelease];</span><br><span class="line">&#125; &#125;</span><br><span class="line">- (void)setValue:(NSString *)aValue</span><br><span class="line">&#123;</span><br><span class="line">  @synchronized(self) &#123;</span><br><span class="line">   [aValue retain];</span><br><span class="line">   [_value release];</span><br><span class="line">   _value = aValue;</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>retain： release旧的对象 retain新的对象</li>
<li>assign：简单赋值 不更改引用计数（默认）</li>
<li>copy：copy相同对象（retain指针拷贝，copy：内容拷贝）</li>
<li>strong： ARC中 同MRC retain一样</li>
<li>weak：同assign一样，weak当指向的内存释放后自动nil话，防止野指针 assign 可以用非 OC 对象,而 weak 必须用于 OC 对象(weak：a.delegate = b, a和b指向同一位置，当b释放 a也释放，如果delegate用assign就会变成野指针)</li>
<li>unsafe_unretained：<strong>weak修饰的对象被释放后，指向对象的指针会置空，也就是指向nil,不会产生野指针；而</strong>unsafe_unretained修饰的对象被释放后，指针不会置空，而是变成一个野指针，那么此时如果访问这个对象的话，程序就会Crash，抛出BAD_ACCESS的异常（它会比weak性能更好，明确对象声明周期时可使用，YYModel内大量使用）</li>
</ul>
<h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><blockquote>
<ul>
<li>序列化：对象-&gt;字节序列</li>
<li>反序列化：字节-&gt; 对象</li>
<li>NSCoding协议、Codable协议</li>
</ul>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h3><blockquote>
<ul>
<li>进程：操作系统多个软件在运行（微信、抖音等）</li>
<li>线程：进程内好多线程</li>
<li>线程是进程的基本组成单元</li>
</ul>
</blockquote>
<h3 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h3><ul>
<li>时间长的任务放到后台处理</li>
<li>程序运行更快</li>
<li>等待任务<h3 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h3></li>
<li>大量影响性能、因为操作系统需要在他们之间切换</li>
<li>占用更多的内存空间</li>
<li>线程死锁</li>
</ul>
<h3 id="多线程实现"><a href="#多线程实现" class="headerlink" title="多线程实现"></a>多线程实现</h3><ul>
<li>Thread</li>
<li>NSOperation</li>
<li>GCD</li>
</ul>
<h2 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func testString(str: String) -&gt; String&#123;</span><br><span class="line">        var dict: [String: Int] = [:]</span><br><span class="line">        var result: String = &quot;&quot;</span><br><span class="line">        let _ = str.map &#123; (char) in</span><br><span class="line">            let temp = &quot;\(char)&quot;</span><br><span class="line">            if dict[temp] == nil &#123;</span><br><span class="line">                result += &quot;\(char)&quot;</span><br><span class="line">                dict[temp] = 10</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="UIImage初始化"><a href="#UIImage初始化" class="headerlink" title="UIImage初始化"></a>UIImage初始化</h2><ul>
<li>imageNamed 检查系统缓存</li>
<li>contentsOfFile: 直接加载</li>
<li>cgImage</li>
</ul>
<h2 id="便利构造器"><a href="#便利构造器" class="headerlink" title="便利构造器"></a>便利构造器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension UIButton &#123;</span><br><span class="line">    convenience init(imageName: String) &#123;</span><br><span class="line">        self.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>iOS 类不可以多继承 可protocol实现</p>
<h2 id="APP启动流程"><a href="#APP启动流程" class="headerlink" title="APP启动流程"></a>APP启动流程</h2><p>main函数 -&gt; UIApplication -&gt; rootVC</p>
<ul>
<li><p>application:willFinishLaunchingWithOptions: - 这个方法是你在启动时的第一次机会来执行代码</p>
</li>
<li><p>application:didFinishLaunchingWithOptions: - 这个方法允许你在显示app给用户之前执行最后的初始化操作</p>
</li>
<li><p>applicationDidBecomeActive: - app已经切换到active状态后需要执行的操作</p>
</li>
<li><p>applicationWillResignActive: - app将要从前台切换到后台时需要执行的操作</p>
</li>
<li><p>applicationDidEnterBackground: - app已经进入后台后需要执行的操作</p>
</li>
<li><p>applicationWillEnterForeground: - app将要从后台切换到前台需要执行的操作，但app还不是active状态</p>
</li>
<li><p>applicationWillTerminate: - app将要结束时需要执行的操作</p>
</li>
</ul>
<h2 id="ViewController-生命周期"><a href="#ViewController-生命周期" class="headerlink" title="ViewController 生命周期"></a>ViewController 生命周期</h2><p>init loadView viewDidLoad viewWillAppear viewWillDisAppear viewDidDisappear didReceiveMemoryWarning deinit/dealloc</p>
<h2 id="字典的工作原理"><a href="#字典的工作原理" class="headerlink" title="字典的工作原理"></a>字典的工作原理</h2><blockquote>
<p>使用hash表来实现key-value之间的映射和存储的</p>
</blockquote>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><ul>
<li>1.开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li>
<li>2.再哈希法</li>
<li>3.链地址法(Java hashmap就是这么做的)</li>
<li>4.建立一个公共溢出区</li>
</ul>
<p>什么是hash冲突？</p>
<p>假设hash表的大小为9（即有9个槽），现在要把一串数据存到表里：5,28,19,15,20,33,12,17,10</p>
<p>简单计算一下：hash(5)=5, 所以数据5应该放在hash表的第5个槽里；hash(28)=1，所以数据28应该放在hash表的第1个槽里；hash(19)=1，也就是说，数据19也应该放在hash表的第1个槽里——于是就造成了碰撞（也称为冲突，collision）。</p>
<p>常用的Hash冲突解决方法有以下几种：</p>
<p>1.开放定址法<br>这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p>
<p>Hi=（H（key）+di）% m i=1，2，…，n</p>
<p>其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：</p>
<p>线性探测再散列</p>
<p>dii=1，2，3，…，m-1</p>
<p>这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p>
<p>二次探测再散列</p>
<p>di=12，-12，22，-22，…，k2，-k2 ( k&lt;=m/2 )</p>
<p>这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p>
<p>伪随机探测再散列</p>
<p>di=伪随机数序列。</p>
<p>具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。</p>
<p>例如，已知哈希表长度m=11，哈希函数为：H（key）= key % 11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。</p>
<p>如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。</p>
<p>如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。</p>
<p>如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。</p>
<p>2.再哈希法<br>这种方法是同时构造多个不同的哈希函数：</p>
<p>Hi=RH1（key） i=1，2，…，k</p>
<p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>
<p>3.链地址法<br>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>
<p>4.建立公共溢出区<br>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>
<p>拉链法与开放地址法相比的缺点：<br>拉链法的优点</p>
<p>与开放定址法相比，拉链法有如下几个优点：</p>
<p>①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p>
<p>②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</p>
<p>③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</p>
<p>④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</p>
<p>拉链法的缺点</p>
<p>　拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>OC：字符串访问 类和方法<br>NSClassFromString NSSelectorFromString<br>Swift: Mirror Class</p>
<h2 id="KVO-实现"><a href="#KVO-实现" class="headerlink" title="KVO 实现"></a>KVO 实现</h2><h2 id="热修复"><a href="#热修复" class="headerlink" title="热修复"></a>热修复</h2><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><h3 id="Block和函数指针的区别"><a href="#Block和函数指针的区别" class="headerlink" title="Block和函数指针的区别"></a>Block和函数指针的区别</h3><p>函数指针是函数地址的引用 block是函数对象</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/27/音视频编解码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/音视频编解码/" itemprop="url">视音频编解码技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-27T16:11:27+08:00">
                2018-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="视频播放器的原理："><a href="#视频播放器的原理：" class="headerlink" title="视频播放器的原理："></a>视频播放器的原理：</h3><p><img src="https://img-blog.csdn.net/20140201120523046?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGVpeGlhb2h1YTEwMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片"></p>
<ul>
<li>解协议: <strong>流媒体协议</strong>(HTTP，RTMP，或是MMS)的数据解析成标准的相应的<strong>封装格式数据</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/30/知识小集/Tips2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/30/知识小集/Tips2/" itemprop="url">iOS 知识小集(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T00:00:00+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/知识小集/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Write more code</li>
<li>Incorporate tests</li>
<li>Be honest</li>
<li>Contribute to open source</li>
<li>Be open to help</li>
<li>Pick a personal project</li>
<li>Lower your ego</li>
<li>Understand the “why”</li>
<li>Don’t be lazy</li>
<li>Solving coding challenges</li>
<li>Encourage the good stuff</li>
<li>Do not hide behind the layer</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/30/知识小集/Tips4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/30/知识小集/Tips4/" itemprop="url">iOS 知识小集(4)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T00:00:00+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/知识小集/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Color Literal<br>Image Literal</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/29/知识小集/Tips3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/29/知识小集/Tips3/" itemprop="url">iOS 知识小集(3)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-29T00:00:00+08:00">
                2018-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/知识小集/" itemprop="url" rel="index">
                    <span itemprop="name">知识小集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> resizableImage: 该方法可以指定一个矩形区域，这个图片在矩形内的部分会拉伸变形，而这个矩形区域外的部分则会保持原样。该方法有如下两个参数：<br>（1）withCapInsets：通过设置 UIEdgeInsets 的 left、right、top、bottom 来分别指定这个矩形区域距离左侧、右侧、顶部、底部的距离。</p>
<p>（2）resizingMode：设置矩形区域的拉伸变形模式，具体有如下两种：</p>
<ul>
<li>.stretch：拉伸模式，通过拉伸 UIEdgeInsets 指定的矩形区域来填充图片。 </li>
<li>.tile：平铺模式，通过重复显示 UIEdgeInsets 指定的矩形区域来填充图片。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let imageView = UIImageView(frame: CGRect(x:10, y:100, width:300, height:66))</span><br><span class="line">let image = UIImage(named: &quot;bg&quot;)?</span><br><span class="line">    .resizableImage(withCapInsets: UIEdgeInsets(top: 0, left: 15, bottom: 0, right: 15),</span><br><span class="line">                    resizingMode: .stretch) //左右15像素的部分不变，中间部分来拉伸</span><br><span class="line">imageView.image = image</span><br><span class="line">view.addSubview(imageView)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/25/WCDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/WCDB/" itemprop="url">WCDB</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T20:12:41+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模型绑定"><a href="#模型绑定" class="headerlink" title="模型绑定"></a>模型绑定</h2><blockquote>
<p>模型绑定（Object-relational Mapping，简称 ORM），通过对 Swift 类或结构进行绑定，形成类或结构 - 表模型、类或结构对象 - 表的映射关系，从而达到通过对象直接操作数据库的目的。</p>
</blockquote>
<ul>
<li>字段映射</li>
<li>字段约束</li>
<li>索引</li>
<li>表约束</li>
<li>虚拟表映射</li>
</ul>
<h3 id="字段映射"><a href="#字段映射" class="headerlink" title="字段映射"></a>字段映射</h3><blockquote>
<p>在类内定义 CodingKeys 的枚举类，并遵循 String 和CodingTableKey。枚举列举每一个需要定义的字段。</p>
</blockquote>
<p>1.别名映射 =&gt; case identifier = “id”</p>
<p>2.对于变量名与 SQLite 的保留关键字冲突 =&gt; case offset = “db_offset”</p>
<h3 id="字段约束"><a href="#字段约束" class="headerlink" title="字段约束"></a>字段约束</h3><blockquote>
<p>它用于定于针对单个字段的约束，如主键约束、非空约束、唯一约束、默认值等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ColumnConstraintBinding(</span><br><span class="line">    isPrimary: Bool = false, // 该字段是否为主键。字段约束中只能同时存在一个主键</span><br><span class="line">    orderBy term: OrderTerm? = nil, // 当该字段是主键时，存储顺序是升序还是降序</span><br><span class="line">    isAutoIncrement: Bool = false, // 当该字段是主键时，其是否支持自增。只有整型数据可以定义为自增。</span><br><span class="line">    onConflict conflict: Conflict? = nil, // 当该字段是主键时，若产生冲突，应如何处理</span><br><span class="line">    isNotNull: Bool = false, // 该字段是否可以为空</span><br><span class="line">    isUnique: Bool = false, // 该字段是否可以具有唯一性</span><br><span class="line">    defaultTo defaultValue: ColumnDef.DefaultType? = nil // 该字段在数据库内使用什么默认值</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let autoIncrementObject = Sample()</span><br><span class="line">autoIncrementObject.isAutoIncrement = true</span><br><span class="line"></span><br><span class="line">// 插入自增数据</span><br><span class="line">try database.insert(objects: autoIncrementObject, intoTable: &quot;sampleTable&quot;)</span><br><span class="line">print(autoIncrementObject.lastInsertedRowID) // 输出 1</span><br><span class="line"></span><br><span class="line">// 再次插入自增数据</span><br><span class="line">try database.insert(objects: autoIncrementObject, intoTable: &quot;sampleTable&quot;)</span><br><span class="line">print(autoIncrementObject.lastInsertedRowID) // 输出 2</span><br><span class="line"></span><br><span class="line">// 插入非自增的指定数据</span><br><span class="line">let specificObject = Sample()</span><br><span class="line">specificObject.identifier = 10</span><br><span class="line">try database.insert(objects: specificObject, intoTable: &quot;sampleTable&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><blockquote>
<p>它用于定于针对单个或多个字段的索引，索引后的数据在能有更高的查询效率。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Sample: TableCodable &#123;</span><br><span class="line">    var identifier: Int? = nil</span><br><span class="line">    var description: String? = nil</span><br><span class="line">    var multiIndexPart1: Int = 0</span><br><span class="line">    var multiIndexPart2: Int = 0</span><br><span class="line">        </span><br><span class="line">    enum CodingKeys: String, CodingTableKey &#123;</span><br><span class="line">        typealias Root = Sample</span><br><span class="line">        static let objectRelationalMapping = TableBinding(CodingKeys.self)</span><br><span class="line">        case identifier</span><br><span class="line">        case description</span><br><span class="line">        case multiIndexPart1</span><br><span class="line">        case multiIndexPart2</span><br><span class="line"></span><br><span class="line">        static var indexBindings: [IndexBinding.Subfix: IndexBinding]? &#123;</span><br><span class="line">            return [</span><br><span class="line">                &quot;_uniqueIndex&quot;: IndexBinding(isUnique: true, indexesBy: identifier),</span><br><span class="line">                &quot;_descendingIndex&quot;: IndexBinding(indexesBy: description.asIndex(orderBy: .descending)),</span><br><span class="line">                &quot;_multiIndex&quot;: IndexBinding(indexesBy: multiIndexPart1, multiIndexPart2.asIndex(orderBy: .ascending))</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>完整的索引名为表名+索引后缀，如：表 “sampleTable” 的索引分别为 “sampleTable_uniqueIndex”、”sampleTable_descendingIndex” 和 “sampleTable_multiIndex”。</p>
</blockquote>
<h3 id="表约束"><a href="#表约束" class="headerlink" title="表约束"></a>表约束</h3><blockquote>
<p>它用于定于针对多个字段或表本身的约束。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Sample: TableCodable &#123;</span><br><span class="line">    var identifier: Int? = nil</span><br><span class="line">    var multiPrimaryKeyPart1: Int = 0</span><br><span class="line">    var multiPrimaryKeyPart2: Int = 0</span><br><span class="line">    var multiUniquePart1: Int = 0</span><br><span class="line">    var multiUniquePart2: Int = 0</span><br><span class="line">        </span><br><span class="line">    enum CodingKeys: String, CodingTableKey &#123;</span><br><span class="line">        typealias Root = Sample</span><br><span class="line">        static let objectRelationalMapping = TableBinding(CodingKeys.self)</span><br><span class="line">        case identifier</span><br><span class="line">        case multiPrimaryKeyPart1</span><br><span class="line">        case multiPrimaryKeyPart2</span><br><span class="line">        case multiUniquePart1</span><br><span class="line">        case multiUniquePart2</span><br><span class="line"></span><br><span class="line">        static var tableConstraintBindings: [TableConstraintBinding.Name: TableConstraintBinding]? &#123;</span><br><span class="line">            let multiPrimaryBinding =</span><br><span class="line">                MultiPrimaryBinding(indexesBy: multiPrimaryKeyPart1.asIndex(orderBy: .descending), multiPrimaryKeyPart2)</span><br><span class="line">            let multiUniqueBinding =</span><br><span class="line">                MultiUniqueBinding(indexesBy: multiUniquePart1, multiUniquePart2.asIndex(orderBy: .ascending))</span><br><span class="line">            return [</span><br><span class="line">                &quot;MultiPrimaryConstraint&quot;: multiPrimaryBinding,</span><br><span class="line">                &quot;MultiUniqueConstraint&quot;: multiUniqueBinding</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.MultiPrimaryBinding: 联合主键约束</p>
<p>2.MultiUniqueBinding: 联合唯一约束</p>
<p>3.CheckBinding: 检查约束</p>
<p>4.ForeignKeyBinding: 外键约束</p>
<h3 id="虚拟表映射"><a href="#虚拟表映射" class="headerlink" title="虚拟表映射"></a>虚拟表映射</h3><blockquote>
<p>它用于定于虚拟表以进行全文搜索等特性。</p>
</blockquote>
<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><blockquote>
<p>插入操作有 “insert” 和 “insertOrReplace” 两个接口。故名思义，前者只是单纯的插入数据，当数据出现冲突时会失败，而后者在主键一致时，新数据会覆盖旧数据。<br>propertyConvertibleList 插入指定字段</p>
</blockquote>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func delete(fromTable table: String, // 表名</span><br><span class="line">            where condition: Condition? = nil, // 符合删除的条件</span><br><span class="line">            orderBy orderList: [OrderBy]? = nil, // 排序的方式</span><br><span class="line">            limit: Limit? = nil, // 删除的个数</span><br><span class="line">            offset: Offset? = nil // 从第几个开始删除</span><br><span class="line">) throws</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将 table 表内，满足 condition 的数据，按照 orderList 的方式进行排序，然后从头开始第 offset 行数据后的 limit 行数据删除</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 删除 sampleTable 中所有 identifier 大于 1 的行的数据</span><br><span class="line">try database.delete(fromTable: &quot;sampleTable&quot;, </span><br><span class="line">                    where: Sample.Properties.identifier &gt; 1)</span><br><span class="line"></span><br><span class="line">// 删除 sampleTable 中 identifier 降序排列后的前 2 行数据</span><br><span class="line">try database.delete(fromTable: &quot;sampleTable&quot;, </span><br><span class="line">                    orderBy: Sample.Properties.identifier.asOrder(by: .descending), </span><br><span class="line">                    limit: 2)</span><br><span class="line"></span><br><span class="line">// 删除 sampleTable 中 description 非空的数据，按 identifier 降序排列后的前 3 行的后 2 行数据</span><br><span class="line">try database.delete(fromTable: &quot;sampleTable&quot;, </span><br><span class="line">                    where: Sample.Properties.description.isNotNull(), </span><br><span class="line">                    orderBy: Sample.Properties.identifier.asOrder(by: .descending), </span><br><span class="line">                    limit: 2,</span><br><span class="line">                    offset: 3)</span><br><span class="line"></span><br><span class="line">// 删除 sampleTable 中的所有数据</span><br><span class="line">try database.delete(fromTable: &quot;sampleTable&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><blockquote>
<p>update with object<br>update with row</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let object = Sample()</span><br><span class="line">object.description = &quot;update&quot;</span><br><span class="line"></span><br><span class="line">// 将 sampleTable 中所有 identifier 大于 1 且 description 字段不为空 的行的 description 字段更新为 &quot;update&quot;</span><br><span class="line">try database.update(table: &quot;sampleTable&quot;</span><br><span class="line">                    on: Sample.Properties.description,</span><br><span class="line">                    with: object,</span><br><span class="line">                    where: Sample.Properites.identifier &gt; 1 &amp;&amp; Sample.Properties.description.isNotNull())</span><br><span class="line"></span><br><span class="line">// 将 sampleTable 中前三行的 description 字段更新为 &quot;update&quot;</span><br><span class="line">try database.update(table: &quot;sampleTable&quot;</span><br><span class="line">                    on: Sample.Properties.description,</span><br><span class="line">                    with: object,</span><br><span class="line">                    limit: 3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let row: [ColumnCodableBase] = [&quot;update&quot;]</span><br><span class="line"></span><br><span class="line">// 将 sampleTable 中所有 identifier 大于 1 且 description 字段不为空 的行的 description 字段更新为 &quot;update&quot;</span><br><span class="line">try database.update(table: &quot;sampleTable&quot;</span><br><span class="line">                    on: Sample.Properties.description,</span><br><span class="line">                    with: row,</span><br><span class="line">                    where: Sample.Properites.identifier &gt; 1 &amp;&amp; Sample.Properties.description.isNotNull())</span><br><span class="line"></span><br><span class="line">// 将 sampleTable 中前三行的 description 字段更新为 &quot;update&quot;</span><br><span class="line">try database.update(table: &quot;sampleTable&quot;</span><br><span class="line">                    on: Sample.Properties.description,</span><br><span class="line">                    with: row,</span><br><span class="line">                    limit: 3)</span><br></pre></td></tr></table></figure>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><ul>
<li>getObjects</li>
<li>getObject</li>
<li>getRows</li>
<li>getRow</li>
<li>getColumn</li>
<li>getDistinctColumn</li>
<li>getValue</li>
<li>getDistinctValue</li>
</ul>
<h4 id="对象查找"><a href="#对象查找" class="headerlink" title="对象查找"></a>对象查找</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 返回 sampleTable 中的所有数据</span><br><span class="line">let allObjects: [Sample] = try database.getObjects(fromTable: &quot;sampleTable&quot;)</span><br><span class="line"></span><br><span class="line">// 返回 sampleTable 中 identifier 小于 5 或 大于 10 的行的数据</span><br><span class="line">let objects: [Sample] = try database.getObjects(fromTable: &quot;sampleTable&quot;, </span><br><span class="line">                                                where: Sample.Properties.identifier &lt; 5 || Sample.Properties.identifier &gt; 10)</span><br><span class="line"></span><br><span class="line">// 返回 sampleTable 中 identifier 最大的行的数据</span><br><span class="line">let object: Sample? = try database.getObject(fromTable: &quot;sampleTable&quot;, </span><br><span class="line">                                             orderBy: Sample.Properties.identifier.asOrder(by: .descending))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 由于对象查找操作使用了范型，因此需要显式声明返回值的类型以匹配范型</p>
</blockquote>
<h4 id="对象部分查询"><a href="#对象部分查询" class="headerlink" title="对象部分查询"></a>对象部分查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let objects: [Sample] = try database.getObjects(fromTable: &quot;sampleTable&quot;, </span><br><span class="line">                                                on: Sample.Properties.identifier)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意:这里只获取了 identifier 字段，而没有获取 description 的值。这就可能与 Swift 本身存在冲突。 Swift 规定了对象创建时，必须初始化所有成员变量。而进行对象部分查询时，则可能出现某部分变量没有变查询，因此无法初始化的情况。因此，对于可能不被查询的成员变量，应将其类型定义为可选值。<br>倘若开发者不确定哪些字段可能会被进行对象部分查询，可以将所有字段都定义为可选。</p>
</blockquote>
<h4 id="值查询操作"><a href="#值查询操作" class="headerlink" title="值查询操作"></a>值查询操作</h4><table>
<thead>
<tr>
<th>identifier</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>“sample1”</td>
</tr>
<tr>
<td>2</td>
<td>“sample2”</td>
</tr>
<tr>
<td>3</td>
<td>“sample3”</td>
</tr>
<tr>
<td>4</td>
<td>“sample4”</td>
</tr>
<tr>
<td>5</td>
<td>“sample5”</td>
</tr>
<tr>
<td>6</td>
<td>“sample6”</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>getRows</strong> 接口获取整个矩阵的所有内容，即返回值为二维数组。</li>
<li><strong>getRow</strong> 接口获取某一横行的数据，即返回值为一维数组。</li>
<li><strong>getColumn</strong> 接口获取某一纵列的数据，即返回值为一维数组。</li>
<li><strong>getDistinctColumn</strong> 与 <strong>getColumn</strong> 类似，但它会过滤掉重复的值。</li>
<li><strong>getValue</strong> 接口获取矩阵中某一个格的内容。</li>
<li><strong>getDistinctValue</strong> 与 <strong>getValue</strong> 类似，但它会过滤掉重复的值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有内容</span><br><span class="line">let allRows = try database.getRows(fromTable: &quot;sampleTable&quot;)</span><br><span class="line">print(allRows[row: 2, column: 0].int32Value) // 输出 3</span><br><span class="line"></span><br><span class="line">// 获取第二行</span><br><span class="line">let secondRow = try database.getRow(fromTable: &quot;sampleTable&quot;, offset: 1)</span><br><span class="line">print(secondRow[0].int32Value) // 输出 2</span><br><span class="line"></span><br><span class="line">// 获取 description 列</span><br><span class="line">let descriptionColumn = try database.getColumn(on: Sample.Properties.description, fromTable: &quot;sampleTable&quot;)</span><br><span class="line">print(descriptionColumn) // 输出 &quot;sample1&quot;, &quot;sample1&quot;, &quot;sample1&quot;, &quot;sample2&quot;, &quot;sample2&quot; </span><br><span class="line"></span><br><span class="line">// 获取不重复的 description 列的值</span><br><span class="line">let distinctDescriptionColumn = try database.getDistinctColumn(on: Sample.Properties.description, fromTable: &quot;sampleTable&quot;)</span><br><span class="line">print(distinctDescriptionColumn) // 输出 &quot;sample1&quot;, &quot;sample2&quot;</span><br><span class="line"></span><br><span class="line">// 获取第二行 description 列的值</span><br><span class="line">let value = try database.getValue(on: Sample.Properties.description, offset: 1)</span><br><span class="line">print(value.stringValue) // 输出 &quot;sample1&quot;</span><br><span class="line"></span><br><span class="line">// 获取 identifier 的最大值</span><br><span class="line">let maxIdentifier = try database.getValue(on: Sample.Properties.identifier.max(), fromTable: &quot;sampleTable&quot;)</span><br><span class="line"></span><br><span class="line">// 获取不重复的 description 的值</span><br><span class="line">let distinctDescription = try database.getDistinctValue(on: Sample.Properties.description, fromTable: &quot;sampleTable&quot;)</span><br><span class="line">print(distinctDescription.stringValue) // 输出 &quot;sample1&quot;</span><br></pre></td></tr></table></figure>
<h2 id="数据库、表、事物"><a href="#数据库、表、事物" class="headerlink" title="数据库、表、事物"></a>数据库、表、事物</h2><blockquote>
<p>数据库 - <code>Database</code>、表 - <code>Table</code> 和 事务 - <code>Transaction</code></p>
</blockquote>
<ul>
<li>支持增删查改的便捷接口</li>
<li>支持链式接口</li>
<li>数据和状态共享</li>
<li>线程安全</li>
</ul>
<p><strong>数据和状态共享</strong>，意味着对于 同一个路径的数据库 的 不同基础类，它们的标签、数据库是否打开、是否在进行读写操作等所有状态和数据都始终保持一致。</p>
<p><strong>线程安全</strong>，意味着开发者可以在 任意线程 对 任意基础类 调用 任意接口，而不需要考虑数据库本身的线程安全问题。同时，WCDB Swift 会根据调用情况，并发执行操作，以达到更高的性能</p>
<p><a href="https://github.com/Tencent/wcdb/wiki/Swift-%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%A1%A8%E3%80%81%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/25/杭州游玩攻略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/杭州游玩攻略/" itemprop="url">杭州游玩美食攻略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T20:12:40+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>自古就有“上有天堂，下有苏杭”的美誉。</p>
<p>鱼米之乡、丝绸之府、 文物之邦，</p>
<p>都是世人对杭州的唯美印象。</p>
<p>整理了杭州的旅游攻略，想去杭州旅游的小伙伴们看过来吧！</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/07/25/杭州游玩攻略/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/25/组件化实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/组件化实践/" itemprop="url">组件化实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T20:12:31+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>组件化大体思路<br><img src="https://upload-images.jianshu.io/upload_images/1064540-f949b35414955594.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/665" alt="持续集成"></p>
<p>框架说明:</p>
<ul>
<li>持续集成: 主工程(壳工程),包含所有内容，用于发布打包等</li>
<li>基础组件: 不依赖其他任何组件，独立完成功能。主要有：与业务无法的功能（如string或data的加密，category的封装）对第三方库的封装（如AFNetworking，SDWebImage的封装）</li>
<li>业务公用组件: 依赖基础组件或UIKit等系统组件，创建业务共同使用的功能（如分享，支付，网络访问）</li>
<li>中间组件: 连接业务公用组件和业务组件，及业务组件之间的互相调用。（如Mediator的组件）</li>
<li>业务组件：单独的业务功能，不依赖其他业务组件。</li>
</ul>
<p>##基础组件：<br>没有业务场景 不允许依赖业务组件</p>
<p>###公共基础<br>多项目可用</p>
<p>###非公共基础<br>ProjectA依赖，但是ProjectB不依赖</p>
<h2 id="桥接层"><a href="#桥接层" class="headerlink" title="桥接层"></a>桥接层</h2><ul>
<li>桥接层的主要作用是为上层业务层和下层基础框架层做桥接，主要考虑底层业务层的开放接口变动频繁以及不适配上层业务。</li>
<li>想要达到每个组件之间相对低耦合，比较常用的方案就是断掉<strong>横向依赖</strong>，使用中间人模式将依赖下沉至<strong>中间件</strong>，而且组件对中间件是<strong>单向依赖</strong></li>
</ul>
<p>##业务组件<br>业务之间不允许相互依赖</p>
<p>隐性依赖库 -&gt; Podfile.lock</p>
<p>##过程</p>
<p>开源组件-&gt;基础组件-&gt;平台中间件-&gt;业务组件-&gt;壳工程</p>
<p>副作用：因为多库开发在发布与集成时 很多依赖冲突lock文件冲突</p>
<p>自动发版与自动集成</p>
<p>壳工程分离</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/03/拾遗/拾遗 - 多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/03/拾遗/拾遗 - 多线程/" itemprop="url">拾遗 - 多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-03T00:00:00+08:00">
                2018-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/拾遗/" itemprop="url" rel="index">
                    <span itemprop="name">拾遗</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ul>
<li>GCD是面向底层的C语言的API，NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象</li>
<li>GCD只支持FIFO队列</li>
<li>NSOperationQueue可设置最大并发数、设置优先级、设置依赖关系等调整执行顺序</li>
<li>NSThread需要我们自己去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>一定是发生在一个或多个线程之间的。那么死锁和线程阻塞的关系呢，可以这么理解，双向的阻塞导致了死锁</p>
<p>多个进程因循环等待资源而造成无法执行的现象</p>
<h3 id="主队列同步"><a href="#主队列同步" class="headerlink" title="主队列同步"></a>主队列同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">  	super.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    DispatchQueue.main.sync &#123;</span><br><span class="line">    	print(&quot;deadlock&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">       </span><br><span class="line">        dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;deadlock&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>解决： 异步或者其它队列</p>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><h3 id="执行顺序：串行队列先异步后同步"><a href="#执行顺序：串行队列先异步后同步" class="headerlink" title="执行顺序：串行队列先异步后同步"></a>执行顺序：串行队列先异步后同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;1&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(serialQueue, ^&#123;</span><br><span class="line">        </span><br><span class="line">         NSLog(@&quot;2&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;3&quot;);</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;4&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;5&quot;);</span><br></pre></td></tr></table></figure>
<p>打印顺序是13245</p>
<p>首先先打印1<br>接下来将任务2其添加至串行队列上，由于任务2是异步，不会阻塞线程，继续向下执行，打印3<br>然后是任务4,将任务4添加至串行队列上，因为任务4和任务2在同一串行队列，根据队列先进先出原则，任务4必须等任务2执行后才能执行，又因为任务4是同步任务，会阻塞线程，只有执行完任务4才能继续向下执行打印5</p>
<p>所以最终顺序就是13245。<br>这里的任务4在主线程中执行，而任务2在子线程中执行。<br>如果任务4是添加到另一个串行队列或者并行队列，则任务2和任务4无序执行(可以添加多个任务看效果)</p>
<h3 id="dispatch-barrier-sync-栅栏函数"><a href="#dispatch-barrier-sync-栅栏函数" class="headerlink" title="dispatch_barrier_sync(栅栏函数)"></a>dispatch_barrier_sync(栅栏函数)</h3><p>场景多读单写：可以多个读者同时读取数据，而在读的时候，不能取写入数据。并且，在写的过程中，不能有其他写者去写。即读者之间是并发的，写者与读者或其他写者是互斥的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (id)readDataForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id result;</span><br><span class="line">    </span><br><span class="line">    dispatch_sync(_concurrentQueue, ^&#123;</span><br><span class="line">       </span><br><span class="line">        result = [self valueForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)writeData:(id)data forKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    dispatch_barrier_async(_concurrentQueue, ^&#123;</span><br><span class="line">       </span><br><span class="line">        [self setValue:data forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h3><p>场景：在n个耗时并发任务都完成后，再去执行接下来的任务。比如，在n个网络请求完成后去刷新UI页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;test1&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    </span><br><span class="line">    for (NSInteger i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">            </span><br><span class="line">            sleep(1);</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;%zd:网络请求&quot;,i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;刷新页面&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Dispatch-Semaphore（信号量）"><a href="#Dispatch-Semaphore（信号量）" class="headerlink" title="Dispatch Semaphore（信号量）"></a>Dispatch Semaphore（信号量）</h3><ul>
<li>保持线程同步，将异步执行任务转换为同步执行任务</li>
<li>保证线程安全，为线程加锁</li>
</ul>
<h3 id="dispatch-after（延时函数）"><a href="#dispatch-after（延时函数）" class="headerlink" title="dispatch_after（延时函数）"></a>dispatch_after（延时函数）</h3><h3 id="dispatch-once（单例）"><a href="#dispatch-once（单例）" class="headerlink" title="dispatch_once（单例）"></a>dispatch_once（单例）</h3><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><a href="https://www.jianshu.com/p/c6ebcc200ce2" target="_blank" rel="noopener">执行顺序</a></p>
<h2 id="NSThread-runloop实现常驻线程"><a href="#NSThread-runloop实现常驻线程" class="headerlink" title="NSThread+runloop实现常驻线程"></a>NSThread+runloop实现常驻线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+ (NSThread *)shareThread &#123;</span><br><span class="line">    </span><br><span class="line">    static NSThread *shareThread = nil;</span><br><span class="line">    </span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        </span><br><span class="line">        shareThread = [[NSThread alloc] initWithTarget:self selector:@selector(threadTest2) object:nil];</span><br><span class="line">        </span><br><span class="line">        [shareThread setName:@&quot;threadTest&quot;];</span><br><span class="line">        </span><br><span class="line">        [shareThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return shareThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)threadTest</span><br><span class="line">&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        </span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        </span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>是一种用于保护多线程共享资源的锁，与一般互斥锁（mutex）不同之处在于当自旋锁尝试获取锁时以忙等待（busy waiting）的形式不断地循环检查锁是否可用。当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会一直等待（不会睡眠），当上一个线程的任务执行完毕，下一个线程会立即执行。<br>在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会进入睡眠状态等待任务执行完毕，当上一个线程的任务执行完毕，下一个线程会自动唤醒然后执行任务。</p>
<h2 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h2><p>自旋锁的优点在于，因为自旋锁不会引起调用者睡眠，所以不会进行线程调度，CPU时间片轮转等耗时操作。所有如果能在很短的时间内获得锁，自旋锁的效率远高于互斥锁。<br>　　缺点在于，自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。自旋锁不能实现递归调用。</p>
<ul>
<li>自旋锁：atomic、OSSpinLock、dispatch_semaphore_t</li>
<li>互斥锁：pthread_mutex、@synchronized、NSLock、NSConditionLock 、NSCondition、NSRecursiveLock</li>
</ul>
<h2 id="atomic和nonatomic的对比"><a href="#atomic和nonatomic的对比" class="headerlink" title="atomic和nonatomic的对比"></a>atomic和nonatomic的对比</h2><ol>
<li>atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。</li>
<li>atomic：系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。getter 还是能得到一个完好无损的对象（可以保证数据的完整性），但这个对象在多线程的情况下是不能确定的，比如上面的例子。<br>也就是说：如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，每次只能有一个线程调用对象的setter方法，所以可以保证数据的完整性。<br>atomic所说的线程安全只是保证了getter和setter存取方法的线程安全，并不能保证整个对象是线程安全的。</li>
<li>nonatomic：就没有这个保证了，nonatomic返回你的对象可能就不是完整的value。因此，在多线程的环境下原子操作是非常必要的，否则有可能会引起错误的结果。但仅仅使用atomic并不会使得对象线程安全，我们还要为对象线程添加lock来确保线程的安全。</li>
<li>nonatomic的速度要比atomic的快。</li>
<li>atomic与nonatomic的本质区别其实也就是在setter方法上的操作不同</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/拾遗/拾遗 - 内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Unruly">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/assets/blogImg/mine.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Unruly的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/拾遗/拾遗 - 内存/" itemprop="url">拾遗 - 内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T00:00:00+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/拾遗/" itemprop="url" rel="index">
                    <span itemprop="name">拾遗</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Autorelease-Pool"><a href="#Autorelease-Pool" class="headerlink" title="Autorelease Pool"></a>Autorelease Pool</h2><h3 id="autoreleasepool结构"><a href="#autoreleasepool结构" class="headerlink" title="@autoreleasepool结构"></a>@autoreleasepool结构</h3><p>单个 autoreleasepool 的运行过程可以简单地理解为 objc_autoreleasePoolPush()、[对象 autorelease] 和 objc_autoreleasePoolPop(void *) 三个过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  void * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>每一个自动释放池都是由一系列的 AutoreleasePoolPage 组成的，并且每一个 AutoreleasePoolPage 的大小都是 4096 字节（16 进制 0x1000）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AutoreleasePoolPage &#123;</span><br><span class="line">    magic_t const magic;</span><br><span class="line">    id *next;</span><br><span class="line">    pthread_t const thread;</span><br><span class="line">    AutoreleasePoolPage * const parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t const depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>自动释放池中的 AutoreleasePoolPage 是以双向链表的形式连接起来的</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的</li>
<li>当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中</li>
<li>调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息</li>
<li>每个线程有一个Runloop 每个Runloop有一个Autorelease Pool</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://draveness.me/autoreleasepool" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 autoreleasepool</a></li>
<li><a href="https://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></li>
</ul>
<h3 id="什么时候释放"><a href="#什么时候释放" class="headerlink" title="什么时候释放"></a>什么时候释放</h3><p>在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop （drain）</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><ul>
<li>delegate</li>
<li>Timer</li>
<li>Block</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/assets/blogImg/mine.jpg"
                alt="Unruly" />
            
              <p class="site-author-name" itemprop="name">Unruly</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/TintGit" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5027328866" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.kalman03.com" title="kalman" target="_blank">kalman</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Unruly</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
